{"block":{"name":"code","text":"<p>Даны ребра взвешенного графа. Напишите функцию, которая выводит кратчайшие расстояния от начальной вершины source до всех остальных, пользуясь алгоритмом Беллмана-Форда. Если в графе содержится отрицательный цикл, выведите -1.</p>\n\n<p><br>\nФормат вывода: в левом столбце - вершины, в правом столбце - кратчайшие расстояния соответствующих вершин. Столбцы разделены пробелом.<br>\nЕсли вершина source = 0, кратчайшее расстояние до вершины 1 = 2, а до 2 = 4.<br>\nТогда вывод будет:</p>\n\n<pre><code class=\"language-no-highlight\">0 0\n1 2\n2 4</code></pre>","video":null,"options":{"execution_time_limit":5,"execution_memory_limit":256,"limits":{"java8":{"time":8,"memory":256},"c++11":{"time":5,"memory":256},"python3":{"time":15,"memory":256}},"code_templates":{"java8":"class Graph\n{\n\tint V,E;\n\tEdge edges[];\n\n\tclass Edge\n\t{\n\t\tint u;\n\t\tint v;\n\t\tint weight;\n\n\t\tEdge(int u, int v, int weight)\n\t\t{\n\t\t\tthis.u = u;\n\t\t\tthis.v = v;\n\t\t\tthis.weight = weight;\t\n\t\t}\n\t}\n\n\tvoid BellmanFord(Graph graph, int source) \n\t{\n        //Write your code here.\n\t}","c++11":"#include <iostream>\nusing namespace std;\n\nstruct Edge\n{\n    int u;\n    int v;\n    int weight;\n};\n\nstruct Graph\n{\n    int V;\n    int E;\n    struct Edge* edges;\n};\n\nvoid BellmanFord(struct Graph* graph, int source)\n{\n    //Write your code here.\n}","python3":"class Graph:  \n\n    def __init__(self, vertices):  \n        self.V = vertices  \n        self.graph = []  \n\n    def BellmanFord(self, src):\n        #Write your code here."},"code_templates_header_lines_count":{"java8":1,"c++11":0,"python3":0},"code_templates_footer_lines_count":{"java8":26,"c++11":18,"python3":12},"code_templates_options":{},"samples":[],"is_run_user_code_allowed":false},"subtitle_files":[],"source":{"code":"# This is a sample Code Challenge\n# Learn more: https://stepik.org/lesson/9173\n# Ask your questions via support@stepik.org\n\ndef generate():\n    return []\n\ndef check(reply, clue):\n    return reply.strip() == clue.strip()\n\n# def solve(dataset):\n#     a, b = dataset.split()\n#     return str(int(a) + int(b))","execution_time_limit":5,"execution_memory_limit":256,"samples_count":0,"templates_data":"::java8\n::header\nimport java.util.*;\n::code\nclass Graph\n{\n\tint V,E;\n\tEdge edges[];\n\t\n\tclass Edge\n\t{\n\t\tint u;\n\t\tint v;\n\t\tint weight;\n\t\t\n\t\tEdge(int u, int v, int weight)\n\t\t{\n\t\t\tthis.u = u;\n\t\t\tthis.v = v;\n\t\t\tthis.weight = weight;\t\n\t\t}\n\t}\n\t\n\tvoid BellmanFord(Graph graph, int source) \n\t{\n        //Write your code here.\n\t}\n::footer\n\tGraph(int vertices, int edges)\n\t{\n\t\tV=vertices;\n\t\tE=edges;\n\t\tthis.edges = new Edge[edges];\n\t\tScanner scan = new Scanner(System.in);\n\t\tfor(int i = 0; i<edges; i++)\n\t\t{\n\t\t\tint u = scan.nextInt();\n        \tint v = scan.nextInt();\n        \tint w = scan.nextInt();\n        \tthis.edges[i] = new Edge(u, v, w);\n\t\t}\n\t}\n\t\n}\nclass Main {\n\tpublic static void main(String args[])\n\t{\n        Scanner scan = new Scanner(System.in);\n        int vertices = scan.nextInt();\n        int edges = scan.nextInt();\n        Graph graph = new Graph(vertices, edges);\n        graph.BellmanFord(graph, 0);  \n\t}\n}\n::c++11\n::header\n::code\n#include <iostream>\nusing namespace std;\n\nstruct Edge\n{\n    int u;\n    int v;\n    int weight;\n};\n\nstruct Graph\n{\n    int V;\n    int E;\n    struct Edge* edges;\n};\n\nvoid BellmanFord(struct Graph* graph, int source)\n{\n    //Write your code here.\n}\n::footer\nstruct Graph* createGraph(int V, int E)\n{\n    struct Graph* graph = new Graph;\n    graph->V = V;\n    graph->E = E;\n    graph->edges = new Edge[E];\n    for(int i = 0; i<E; i++)\n        cin >> graph->edges[i].u >> graph->edges[i].v >> graph->edges[i].weight;\n    return graph;\n}\nint main()\n{\n    int vertices,edges;\n    cin >> vertices >> edges;\n    struct Graph* graph = createGraph(vertices, edges);\n    BellmanFord(graph, 0);\n    return 0;\n}\n::python3\n::header\n::code\nclass Graph:  \n  \n    def __init__(self, vertices):  \n        self.V = vertices  \n        self.graph = []  \n         \n    def BellmanFord(self, src):\n        #Write your code here.\n        \n::footer            \n    def addEdge(self, u, v, w):  \n        self.graph.append([u, v, w])    \n\nvertices, edges = input().split()\nvertices = int(vertices)\nedges = int(edges)\ng = Graph(vertices)\nfor i in range(0, edges):\n    u, v, w = input().split()\n    g.addEdge(int(u),int(v),int(w))\n    \ng.BellmanFord(0)\n\n\n","is_time_limit_scaled":true,"is_memory_limit_scaled":true,"is_run_user_code_allowed":false,"manual_time_limits":[],"manual_memory_limits":[],"test_archive":[],"test_cases":[["6 8\n1 2 -2\n0 2 3\n3 4 6\n4 3 2\n5 4 4\n0 5 1\n0 1 5\n2 3 4","0 0\n1 5\n2 3\n3 7\n4 5\n5 1"],["4 5\n1 3 4\n3 2 1\n2 1 -10\n0 1 2\n0 2 3","-1"],["6 9\n0 1 6\n0 2 4\n0 3 5\n2 1 -2\n3 2 -2\n3 5 -1\n4 5 3\n1 4 -1\n2 4 3","0 0\n1 1\n2 3\n3 5\n4 0\n5 3"],["4 4\n0 1 1\n1 2 3\n2 3 2\n3 1 -6","-1"],["7 10\n0 1 6\n0 2 5\n0 3 5\n1 4 -1\n2 1 -2\n2 4 1\n3 2 -2\n3 5 -1\n4 6 3\n5 6 3","0 0\n1 1\n2 3\n3 5\n4 0\n5 4\n6 3"],["5 6\n0 1 6\n1 2 4\n2 0 -1\n2 4 -2\n1 3 20\n3 4 -3","0 0\n1 6\n2 10\n3 26\n4 8"],["5 7\n0 1 6\n1 2 4\n2 0 -1\n2 4 -2\n1 3 20\n3 4 -3\n1 4 -1","0 0\n1 6\n2 10\n3 26\n4 5"],["5 7\n0 1 6\n1 2 4\n2 0 -1\n2 4 -2\n1 3 -20\n3 4 -3\n1 4 -1","0 0\n1 6\n2 10\n3 -14\n4 -17"],["5 7\n0 1 -6\n1 2 4\n2 0 -1\n2 4 -2\n1 3 20\n3 4 -3\n1 4 -1","-1"],["5 7\n0 1 6\n1 2 -4\n2 0 -1\n2 4 -2\n1 3 20\n3 4 -3\n1 4 -1","0 0\n1 6\n2 2\n3 26\n4 0"]],"are_all_tests_scored":false,"are_all_tests_run":true},"subtitles":{},"tests_archive":"/api/step-sources/1455062/tests","feedback_correct":"","feedback_wrong":""},"id":"1455062","has_review":false,"time":"2020-08-01T19:04:09.785Z"}