{"block":{"name":"text","text":"<p>В прошлом алгоритме мы находили лишь кратчайшие расстояния, а не конкретный путь.<br>\nНа самом деле это довольно просто исправить.<br>\nДопустим на каком-то шаге мы поменяли значение кратчайшего расстояния для вершины D, а вершина которая поменяла это расстояние(у которой мы рассматривали всех соседей) - вершина C. Давайте будем хранить эту вершину C как последнюю вершину, которая изменила расстояние для D. Когда алгоритм отработает полностью, каждой вершине будет сопоставлена последняя вершина, которая изменила ее кратчайшее расстояние. <br>\nТо есть, если кратчайший путь от A до E выглядит как: A-&gt;F-&gt;B-&gt;E, то вершине E сопоставляется вершина B.<br>\nХраня эту информацию мы можем находить кратчайшие пути для каждой вершины:<br>\n<img alt=\"\" src=\"https://ucarecdn.com/f020028f-d254-45ed-b676-c2fbd5ed39e7/\"><br>\n<img alt=\"\" src=\"https://ucarecdn.com/c4aca29e-f3d4-418a-9c29-5a442e800e3f/\"><br>\n<img alt=\"\" src=\"https://ucarecdn.com/4615f571-aae2-4ab7-a103-a666d5d309af/\"><br>\n<img alt=\"\" src=\"https://ucarecdn.com/0399077f-3ea1-4ccc-b3cf-38dd49d5825d/\"></p>\n\n<p>Теперь, чтобы узнать кратчайший путь для вершины E к примеру, будем делать вот что:<br>\n<img alt=\"\" src=\"https://ucarecdn.com/fe0a148b-b445-4132-9913-51cd01aa3fcb/\"><br>\nДля каждой вершины существует родитель - это предыдущая вершина в кратчайшем пути. Тогда если мы выберем родительскую вершину как предыдущую вершину в пути от конечной вершины, то мы снова вернемся к той же задаче, только теперь вместо вершины E будет вершина F(как в примере выше). Повторяя этот процесс до тех пор пока родительская вершина не будет равна null(или другому отличающему объекту) мы получим кратчайший путь.</p>\n\n<p>Если бы вершины обозначались через числа, то можно было бы создать массив, индексы которого обозначали бы вершины графа. Элемент массива равного source-вершине приравняем к -1. Все остальные элементы массива - родители.</p>\n\n<pre><code class=\"language-cpp\">cout &lt;&lt; i &lt;&lt; \" \";\nwhile(parent[i]!=-1)\n{\n   i = parent[i];\n   cout &lt;&lt; i &lt;&lt; \" \";\n}</code></pre>\n\n<p>Ответ правда в этой реализации выведется в обратном порядке, но можно придумать способы как сделать в правильном.</p>","video":null,"options":{},"subtitle_files":[],"source":{},"subtitles":{},"tests_archive":null,"feedback_correct":"","feedback_wrong":""},"id":"1454381","has_review":false,"time":"2020-08-01T19:03:31.351Z"}