{"block":{"name":"code","text":"<p>Напишите функции, которые будут выводить через пробел вершины бинарного дерева в прямом, центрированном и обратном порядке.</p>","video":null,"options":{"execution_time_limit":5,"execution_memory_limit":256,"limits":{"java8":{"time":8,"memory":256},"python3":{"time":15,"memory":256},"c++11":{"time":5,"memory":256}},"code_templates":{"java8":"import java.util.*;        \nclass BinaryTree\n{\n\tNode root;\n\tclass Node\n\t{\n\t\tint value;\n\t\tNode left, right;\n\t\tNode(int value)\n\t\t{\n\t\t\tthis.value = value;\n\t\t\tleft = right = null;\n\t\t}\n\t}\n    public void PreOrderTraversal(Node root)\n\t{\n\t\t// Write your code here.\t\n\t}\n\n    public void InOrderTraversal(Node root)\n    {\n        // Write your code here.\n    }\n\n    public void PostOrderTraversal(Node root)\n    {\n        //Write your code here.\n    }","python3":"class Node: \n    def __init__(self ,key): \n        self.data = key \n        self.left = None\n        self.right = None\n\ndef PreOrderTraversal(root): \n    #Write your code here.\n\ndef InOrderTraversal(root): \n    #Write your code here.\n\ndef PostOrderTraversal(root): \n    #Write your code here.","c++11":"#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\nstruct Node\n{\n    int data;\n    struct Node *left, *right;\n};\n\nvoid PreOrderTraversal(Node *root)\n{\n   //Write your code here. \n}\n\nvoid InOrderTraversal(Node *root)\n{\n    //Write your code here.\n}\n\nvoid PostOrderTraversal(Node *root)\n{\n    //Write your code here.\n}"},"code_templates_header_lines_count":{"java8":0,"python3":0,"c++11":0},"code_templates_footer_lines_count":{"java8":44,"python3":39,"c++11":62},"code_templates_options":{},"samples":[],"is_run_user_code_allowed":false},"subtitle_files":[],"source":{"code":"# This is a sample Code Challenge\n# Learn more: https://stepik.org/lesson/9173\n# Ask your questions via support@stepik.org\n\ndef generate():\n    return []\n\ndef check(reply, clue):\n    return reply.strip() == clue.strip()\n\n# def solve(dataset):\n#     a, b = dataset.split()\n#     return str(int(a) + int(b))","execution_time_limit":5,"execution_memory_limit":256,"samples_count":0,"templates_data":"::java8\n::code  \nimport java.util.*;        \nclass BinaryTree\n{\n\tNode root;\n\tclass Node\n\t{\n\t\tint value;\n\t\tNode left, right;\n\t\tNode(int value)\n\t\t{\n\t\t\tthis.value = value;\n\t\t\tleft = right = null;\n\t\t}\n\t}\n    public void PreOrderTraversal(Node root)\n\t{\n\t\t// Write your code here.\t\n\t}\n    \n    public void InOrderTraversal(Node root)\n    {\n        // Write your code here.\n    }\n    \n    public void PostOrderTraversal(Node root)\n    {\n        //Write your code here.\n    }\n::footer\n    void createNode(int parent[], int i, Node created[])\n\t{\n\t\tif(created[i]!=null)\n\t\t\treturn;\n\t\tcreated[i] = new Node(i);\n\t\tif(parent[i] == -1)\n\t\t{\n\t\t\troot = created[i];\n\t\t\treturn;\n\t\t}\n\t\tif(created[parent[i]]==null)\n\t\t\tcreateNode(parent,parent[i],created);\n\t\tNode p = created[parent[i]];\n\t\tif(p.left == null)\n\t\t\tp.left = created[i];\n\t\telse\n\t\t\tp.right = created[i];\n\t}\n\tvoid createTree(int parent[], int n)\n\t{\n\t\tNode[] created = new Node[n];\n\t\tfor(int i = 0; i<n; i++)\n\t\t\tcreated[i] = null;\n\t\tfor(int i = 0;i<n; i++)\n\t\t\tcreateNode(parent, i, created);\n\t}\n}\nclass Main {\n\tpublic static void main(String args[])\n\t{\n\t\tBinaryTree tree = new BinaryTree();\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint parent[] = new int[n];\n\t\tfor(int i = 0; i<n;i++)\n\t\t\tparent[i] = scan.nextInt();\n\t\ttree.createTree(parent, n);\n\t\ttree.PreOrderTraversal(tree.root);\n        System.out.println();\n        tree.InOrderTraversal(tree.root);\n        System.out.println();\n        tree.PostOrderTraversal(tree.root);\n\t}\n}\n::python3\n::header\n::code\nclass Node: \n    def __init__(self ,key): \n        self.data = key \n        self.left = None\n        self.right = None\n\ndef PreOrderTraversal(root): \n    #Write your code here.\n    \ndef InOrderTraversal(root): \n    #Write your code here.\n    \ndef PostOrderTraversal(root): \n    #Write your code here.\n\n::footer    \ndef createNode(parent, i, created, root): \n  \n    if created[i] is not None: \n        return\n   \n    created[i] = Node(i) \n   \n    if parent[i] == -1: \n        root[0] = created[i] \n        return\n   \n    if created[parent[i]] is None: \n        createNode(parent, parent[i], created, root ) \n   \n    p = created[parent[i]] \n   \n    if p.left is None: \n        p.left = created[i] \n    else: \n        p.right = created[i]\n\ndef createTree(parent): \n    n = len(parent) \n\n    created = [None for i in range(n+1)] \n      \n    root = [None] \n    for i in range(n): \n        createNode(parent, i, created, root) \n  \n    return root[0]\n\nif __name__ == '__main__':\n    n = int(input())\n    parent = [int(i) for i in input().split()]\n    root = createTree(parent)\n    PreOrderTraversal(root)\n    InOrderTraversal(root)\n    PostOrderTraversal(root)\n::c++11\n::header\n::code\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\nstruct Node\n{\n    int data;\n    struct Node *left, *right;\n};\n\nvoid PreOrderTraversal(Node *root)\n{\n   //Write your code here. \n}\n\nvoid InOrderTraversal(Node *root)\n{\n    //Write your code here.\n}\n\nvoid PostOrderTraversal(Node *root)\n{\n    //Write your code here.\n}\n::footer\nNode *newNode(int key)\n{\n    Node *temp = new Node;\n    temp->data  = key;\n    temp->left  = temp->right = nullptr;\n    return (temp);\n}\n\nvoid createNode(vector<int> &parent, int i, Node *created[], Node **root)\n{\n    if (created[i] != nullptr)\n        return;\n\n    created[i] = newNode(i);\n\n    if (parent[i] == -1)\n    {\n        *root = created[i];\n        return;\n    }\n\n    if (created[parent[i]] == nullptr)\n        createNode(parent, parent[i], created, root);\n\n    Node *p = created[parent[i]];\n\n    if (p->left == nullptr)\n        p->left = created[i];\n    else\n        p->right = created[i];\n}\n\nNode *createTree(vector<int> &parent, int n)\n{\n    Node *created[n];\n    for (int i=0; i<n; i++)\n        created[i] = nullptr;\n\n    Node *root = nullptr;\n    for (int i=0; i<n; i++)\n        createNode(parent, i, created, &root);\n\n    return root;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<int> parent;\n    for(int i = 0; i<n; i++)\n    {\n        int item;\n        cin >> item;\n        parent.push_back(item);\n    }\n    Node *root = createTree(parent, n);\n    PreOrderTraversal(root);\n    InOrderTraversal(root);\n    PostOrderTraversal(root);\n    return 0;\n}\n","is_time_limit_scaled":true,"is_memory_limit_scaled":true,"is_run_user_code_allowed":false,"manual_time_limits":[],"manual_memory_limits":[],"test_archive":[],"test_cases":[["7\n-1 0 0 1 1 2 2","0 1 3 4 2 5 6 \n3 1 4 0 5 2 6 \n3 4 1 5 6 2 0 "],["7\n1 5 5 2 2 -1 3","5 1 0 2 3 6 4 \n0 1 5 6 3 2 4 \n0 1 6 3 4 2 5 "],["6\n-1 0 1 2 3 4","0 1 2 3 4 5 \n5 4 3 2 1 0 \n5 4 3 2 1 0 "],["15\n-1 0 1 2 3 4 1 6 6 7 7 8 8 9 11","0 1 2 3 4 5 6 7 9 13 10 8 11 14 12 \n5 4 3 2 1 13 9 7 10 6 14 11 8 12 0 \n5 4 3 2 13 9 10 7 14 11 12 8 6 1 0 "]],"are_all_tests_scored":false},"subtitles":{},"tests_archive":"/api/step-sources/1446305/tests","feedback_correct":"","feedback_wrong":""},"id":"1446305","has_review":false,"time":"2020-08-01T19:01:28.526Z"}