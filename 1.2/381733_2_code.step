{"block":{"name":"code","text":"<p>Вам дан корень бинарного дерева. Напишите функцию, которая выводит через пробел значения вершин этого дерева, используя алгоритм обхода в ширину.</p>","video":null,"options":{"execution_time_limit":5,"execution_memory_limit":256,"limits":{"python3":{"time":15,"memory":256},"c++11":{"time":5,"memory":256},"java8":{"time":8,"memory":256}},"code_templates":{"python3":"class Node: \n    def __init__(self ,key): \n        self.data = key \n        self.left = None\n        self.right = None\n\ndef printLevelOrder(root): \n    #Write your code here.","c++11":"#include <iostream>\n#include <queue>\nusing namespace std;\nstruct Node\n{\n    int data;\n    struct Node *left, *right;\n};\n\nvoid printLevelOrder(Node *root)\n{\n    //Write your code here.\n}","java8":"import java.util.*;        \nclass BinaryTree\n{\n\tNode root;\n\tclass Node\n\t{\n\t\tint data;\n\t\tNode left, right;\n\t\tNode(int value)\n\t\t{\n\t\t\tdata = value;\n\t\t\tleft = right = null;\n\t\t}\n\t}\n    public void levelOrderTraversal(Node root)\n\t{\n\t\t// Write your code here.\t\n\t}"},"code_templates_header_lines_count":{"python3":0,"c++11":1,"java8":0},"code_templates_footer_lines_count":{"python3":37,"c++11":60,"java8":40},"code_templates_options":{},"samples":[],"is_run_user_code_allowed":false},"subtitle_files":[],"source":{"code":"# This is a sample Code Challenge\n# Learn more: https://stepik.org/lesson/9173\n# Ask your questions via support@stepik.org\n\ndef generate():\n    return []\n\ndef check(reply, clue):\n    return reply.strip() == clue.strip()\n\n# def solve(dataset):\n#     a, b = dataset.split()\n#     return str(int(a) + int(b))","execution_time_limit":5,"execution_memory_limit":256,"samples_count":0,"templates_data":"::python3\n::header\n::code\nclass Node: \n    def __init__(self ,key): \n        self.data = key \n        self.left = None\n        self.right = None\n\ndef printLevelOrder(root): \n    #Write your code here.\n::footer\ndef createNode(parent, i, created, root): \n  \n    if created[i] is not None: \n        return\n   \n    created[i] = Node(i) \n   \n    if parent[i] == -1: \n        root[0] = created[i] \n        return\n   \n    if created[parent[i]] is None: \n        createNode(parent, parent[i], created, root ) \n   \n    p = created[parent[i]] \n   \n    if p.left is None: \n        p.left = created[i] \n    else: \n        p.right = created[i]\n\ndef createTree(parent): \n    n = len(parent) \n\n    created = [None for i in range(n+1)] \n      \n    root = [None] \n    for i in range(n): \n        createNode(parent, i, created, root) \n  \n    return root[0]\n\nif __name__ == '__main__':\n    n = int(input())\n    parent = [int(i) for i in input().split()]\n    root = createTree(parent)\n    printLevelOrder(root)    \n::c++11\n::header\n#include <vector>\n::code\n#include <iostream>\n#include <queue>\nusing namespace std;\nstruct Node\n{\n    int data;\n    struct Node *left, *right;\n};\n\nvoid printLevelOrder(Node *root)\n{\n    //Write your code here.\n}\n::footer\nNode *newNode(int key)\n{\n    Node *temp = new Node;\n    temp->data  = key;\n    temp->left  = temp->right = nullptr;\n    return (temp);\n}\n\nvoid createNode(vector<int> parent, int i, Node *created[], Node **root)\n{\n    if (created[i] != nullptr)\n        return;\n\n    created[i] = newNode(i);\n\n    if (parent[i] == -1)\n    {\n        *root = created[i];\n        return;\n    }\n\n    if (created[parent[i]] == nullptr)\n        createNode(parent, parent[i], created, root);\n\n    Node *p = created[parent[i]];\n\n    if (p->left == nullptr)\n        p->left = created[i];\n    else\n        p->right = created[i];\n}\n\nNode *createTree(vector<int> parent, int n)\n{\n    Node *created[n];\n    for (int i=0; i<n; i++)\n        created[i] = nullptr;\n\n    Node *root = nullptr;\n    for (int i=0; i<n; i++)\n        createNode(parent, i, created, &root);\n\n    return root;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<int> parent;\n    for(int i = 0; i<n; i++)\n    {\n        int item;\n        cin >> item;\n        parent.push_back(item);\n    }\n    Node *root = createTree(parent, n);\n    printLevelOrder(root);\n    return 0;\n}      \n::java8\n::code  \nimport java.util.*;        \nclass BinaryTree\n{\n\tNode root;\n\tclass Node\n\t{\n\t\tint data;\n\t\tNode left, right;\n\t\tNode(int value)\n\t\t{\n\t\t\tdata = value;\n\t\t\tleft = right = null;\n\t\t}\n\t}\n    public void levelOrderTraversal(Node root)\n\t{\n\t\t// Write your code here.\t\n\t}\n::footer\n    void createNode(int parent[], int i, Node created[])\n\t{\n\t\tif(created[i]!=null)\n\t\t\treturn;\n\t\tcreated[i] = new Node(i);\n\t\tif(parent[i] == -1)\n\t\t{\n\t\t\troot = created[i];\n\t\t\treturn;\n\t\t}\n\t\tif(created[parent[i]]==null)\n\t\t\tcreateNode(parent,parent[i],created);\n\t\tNode p = created[parent[i]];\n\t\tif(p.left == null)\n\t\t\tp.left = created[i];\n\t\telse\n\t\t\tp.right = created[i];\n\t}\n\tvoid createTree(int parent[], int n)\n\t{\n\t\tNode[] created = new Node[n];\n\t\tfor(int i = 0; i<n; i++)\n\t\t\tcreated[i] = null;\n\t\tfor(int i = 0;i<n; i++)\n\t\t\tcreateNode(parent, i, created);\n\t}\n}\nclass Main {\n\tpublic static void main(String args[])\n\t{\n\t\tBinaryTree tree = new BinaryTree();\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint parent[] = new int[n];\n\t\tfor(int i = 0; i<n;i++)\n\t\t\tparent[i] = scan.nextInt();\n\t\ttree.createTree(parent, n);\n\t\ttree.levelOrderTraversal(tree.root);\n\t}\n}","is_time_limit_scaled":true,"is_memory_limit_scaled":true,"is_run_user_code_allowed":false,"manual_time_limits":[],"manual_memory_limits":[],"test_archive":[],"test_cases":[["7\n1 5 5 2 2 -1 3","5 1 2 0 3 4 6"],["7\n-1 0 0 1 1 3 5","0 1 2 3 4 5 6"],["4\n1 3 1 -1","3 1 0 2"],["7\n1 3 1 -1 2 3 0","3 1 5 0 2 6 4"],["7\n4 4 1 0 6 0 -1","6 4 0 1 3 5 2"],["3\n1 -1 0","1 0 2"],["3\n2 -1 1","1 2 0 "],["4\n2 2 -1 0","2 0 1 3"],["5\n1 -1 0 1 3","1 0 3 2 4"],["5\n1 -1 4 1 3","1 0 3 4 2"]],"are_all_tests_scored":false,"are_all_tests_run":true},"subtitles":{},"tests_archive":"/api/step-sources/1439601/tests","feedback_correct":"","feedback_wrong":""},"id":"1439601","has_review":false,"time":"2020-08-01T19:01:21.033Z"}