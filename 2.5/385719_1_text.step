{"block":{"name":"text","text":"<p>Алгоритм Ли используется для поиска кратчайшего пути в лабиринте между двумя заданными точками.<br>\nВ его основе лежит BFS(breadth-first-search).<br>\n<strong>Идея алгоритма:</strong></p>\n\n<pre><code class=\"language-no-highlight\">1. Вставляем начальную ячейку в очередь, определяем расстояние от начальной ячейки до самой себя за 0 и помечаем ее как посещенную.\n2. Вытаскиваем элемент X из очереди.\n3. Рассматриваем всех соседей элемента X. Если сосед не посещен и не преграда, то запоминаем его как посещенный, сопоставляем ему расстояние как расстояние для X и +1, вставляем его в очередь.\n4. Выполняем шаги 3-4 до тех пор, пока очередь не опустеет или мы не дойдем до искомой ячейки.</code></pre>\n\n<p>Рассмотрим пример работы алгоритма, нам доступно ходить только влево ,вправо, вперед, вниз:<br>\n<img alt=\"\" src=\"https://ucarecdn.com/da472b57-3758-46c1-be49-8ba95cdecf66/\"><br>\nТаким образом мы выяснили, что самый короткий путь от зеленой клетки до желтой составляет 7 шагов.<br>\nМы нашли только количество шагов, а не сам путь. На самом деле довольно просто получить этот путь.<br>\nНачинаем с желтой клетки, смотрим на ее соседей и ищем соседа со значением на 1 меньше чем у желтой клетки, таких соседей может быть несколько, это означает, что существует несколько кратчайших путей. Переходим на эту клетку и ищем снова. Таким образом каждый раз уменьшая расстояние на 1 мы будем записывать посещенные вершины и в конечном итоге придем к клетке со значением 0(начальной клетке).</p>","video":null,"options":{},"subtitle_files":[],"source":{},"subtitles":{},"tests_archive":null,"feedback_correct":"","feedback_wrong":""},"id":"1456596","has_review":false,"time":"2020-08-03T13:23:29.702Z"}