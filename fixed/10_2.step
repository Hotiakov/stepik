{"block":{"name":"code","text":"<p>Дана матрица смежности связного графа и начальная вершина. Воспользуйтесь алгоритмом Дейкстры и напишите функцию, которая будет выводить кратчайшие расстояния от заданной вершины до остальных.<br>\n<br>\nВершины графа пронумерованы.<br>\ngraph - матрица смежности, source - начальная вершина.<br>\nТакже вам дана дополнительная функция minDistance, которая возвращает не посещенную вершину с минимальным расстоянием до начальной вершины.<br>\ndist - массив с текущими кратчайшими путями до начальной вершины, visited - массив показывающий посещенные/не посещенные вершины.<br>\nВы можете менять функцию minDistance, а можете не использовать ее совсем.<br>\n<br>\n<strong>Пример:</strong></p>\n\n<p style=\"text-align: center;\"><img alt=\"\" height=\"192\" src=\"https://ucarecdn.com/73e156f8-ef1a-4a50-8446-eadcce1af1fa/\" width=\"400\"></p>\n\n<p>Красным  отмечены кратчайшие расстояния от вершины 0.</p>\n\n<p>Программа должна вывести:</p>\n\n<pre><code class=\"language-no-highlight\">0 0\n1 3\n2 10\n3 17\n4 18\n5 16\n6 12\n7 5\n8 9</code></pre>\n\n<p>В левом столбце - вершины, в правом - кратчайшие расстояния до начальной вершины.<br>\nОбратите внимание, что кратчайшее расстояние от начальной вершины до самой себе равно 0.<br>\n </p>","video":null,"options":{"execution_time_limit":5,"execution_memory_limit":256,"limits":{"java8":{"time":8,"memory":256},"python3":{"time":15,"memory":256},"c++11":{"time":5,"memory":256}},"code_templates":{"java8":"int minDistance(int dist[], boolean visited[]) \n    { \n        int min = 9999;\n        int min_index = -1; \n        for (int v = 0; v < dist.length; v++) \n            if (visited[v] == false && dist[v] <= min) \n            { \n                min = dist[v]; \n                min_index = v; \n            } \n        return min_index; \n    }\n\tvoid dijkstra(int graph[][], int source) \n    {\n        //Write your code here.\n    }","python3":"class Graph(): \n\n    def __init__(self, vertices): \n        self.V = vertices \n        self.graph = [[0 for column in range(vertices)] for row in range(vertices)]  \n\n    def minDistance(self, dist, visited):   \n        minItem = 9999 \n        min_index = -1\n        for v in range(self.V): \n            if dist[v] < minItem and visited[v] == False: \n                minItem = dist[v] \n                min_index = v \n        return min_index\n\n    def dijkstra(self, source):\n        #Write your code here.","c++11":"#include <iostream>\n#include <vector>\nusing namespace std;\n\nint minDistance(vector<int> dist, vector<bool> visited)\n{\n    int min = 9999;\n    int min_index;\n    for (int v = 0; v < dist.size(); v++)\n        if (!visited[v] && dist[v] <= min)\n            min = dist[v], min_index = v;\n    return min_index;\n}\n\nvoid dijkstra(vector<vector<int>> graph, int source)\n{\n    //Write code here.\n}"},"code_templates_header_lines_count":{"java8":6,"python3":0,"c++11":0},"code_templates_footer_lines_count":{"java8":14,"python3":6,"c++11":18},"code_templates_options":{},"samples":[],"is_run_user_code_allowed":false},"subtitle_files":[],"source":{"code":"# This is a sample Code Challenge\n# Learn more: https://stepik.org/lesson/9173\n# Ask your questions via support@stepik.org\n\ndef generate():\n    return []\n\ndef check(reply, clue):\n    return reply.strip() == clue.strip()\n\n# def solve(dataset):\n#     a, b = dataset.split()\n#     return str(int(a) + int(b))","execution_time_limit":5,"execution_memory_limit":256,"samples_count":0,"templates_data":"::java8\n::header\nimport java.util.*;        \nimport java.lang.*; \nimport java.io.*;\n\nclass ShortestPath\n{\n::code\n    \n    int minDistance(int dist[], boolean visited[]) \n    { \n        int min = 9999;\n        int min_index = -1; \n        for (int v = 0; v < dist.length; v++) \n            if (visited[v] == false && dist[v] <= min) \n            { \n                min = dist[v]; \n                min_index = v; \n            } \n        return min_index; \n    }\n\tvoid dijkstra(int graph[][], int source) \n    {\n        //Write your code here.\n    }\n::footer\n}\nclass Main {\n\tpublic static void main(String args[])\n\t{\n        Scanner scan = new Scanner(System.in);\n        int n = scan.nextInt();\n        int graph[][] = new int[n][n];\n        for(int i = 0;i < n; i++)\n            for(int j = 0; j < n; j++)\n                graph[i][j] = scan.nextInt();\n        ShortestPath ans = new ShortestPath(); \n        ans.dijkstra(graph, 0);\n\t}\n}\n::python3\n::header\n::code\nclass Graph(): \n  \n    def __init__(self, vertices): \n        self.V = vertices \n        self.graph = [[0 for column in range(vertices)] for row in range(vertices)]  \n         \n    def minDistance(self, dist, visited):   \n        minItem = 9999 \n        min_index = -1\n        for v in range(self.V): \n            if dist[v] < minItem and visited[v] == False: \n                minItem = dist[v] \n                min_index = v \n        return min_index\n    \n    def dijkstra(self, source):\n        #Write your code here.\n::footer          \nif __name__ == '__main__':\n    m = int(input())\n    g = Graph(m)        \n    for i in range(m):\n        g.graph[i]=([int(j) for j in input().split()])\n    g.dijkstra(0)\n\n::c++11\n::header\n::code\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint minDistance(vector<int> dist, vector<bool> visited)\n{\n    int min = 9999;\n    int min_index;\n    for (int v = 0; v < dist.size(); v++)\n        if (!visited[v] && dist[v] <= min)\n            min = dist[v], min_index = v;\n    return min_index;\n}\n\nvoid dijkstra(vector<vector<int>> graph, int source)\n{\n    //Write code here.\n}\n::footer\nint main()\n{\n    int n;\n    cin >> n;\n    vector<vector<int>> matrix;\n    for(int i = 0; i < n; i++){\n        vector<int> row;\n        for(int j = 0; j < n; j++)\n        {\n            int item;\n            cin >> item;\n            row.push_back(item);\n        }\n        matrix.push_back(row);\n    }\n    dijkstra(matrix,0);\n    return 0;\n}","is_time_limit_scaled":true,"is_memory_limit_scaled":true,"is_run_user_code_allowed":false,"manual_time_limits":[],"manual_memory_limits":[],"test_archive":[],"test_cases":[["9\n0 4 0 0 0 0 0 8 0\n4 0 8 0 0 0 0 11 0\n0 8 0 7 0 4 0 0 2\n0 0 7 0 9 14 0 0 0\n0 0 0 9 0 10 0 0 0\n0 0 4 14 10 0 2 0 0\n0 0 0 0 0 2 0 1 6\n8 11 0 0 0 0 1 0 7\n0 0 2 0 0 0 6 7 0","0 0\n1 4\n2 12\n3 19\n4 21\n5 11\n6 9\n7 8\n8 14"],["9\n0 3 0 0 0 0 0 5 0 \n3 0 0 7 0 0 0 0 0 \n0 0 0 11 13 1 0 0 0 \n0 7 11 0 0 6 0 0 2 \n0 0 13 0 0 2 0 0 0 \n0 0 1 6 2 0 9 0 0 \n0 0 0 0 0 9 0 10 3 \n5 0 0 0 0 0 10 0 4 \n0 0 0 2 0 0 3 4 0","0 0\n1 3\n2 17\n3 10\n4 18\n5 16\n6 12\n7 5\n8 9"],["2\n0 2\n2 0","0 0\n1 2"],["4\n0 2 5 1 \n2 0 0 3 \n5 0 0 4\n1 3 4 0","0 0\n1 2\n2 5\n3 1"],["5\n0 2 5 1 1 \n2 0 0 3 4 \n5 0 0 4 0 \n1 3 4 0 0 \n1 4 0 0 0","0 0\n1 2\n2 5\n3 1\n4 1"],["7\n0 2 5 1 1 0 0 \n2 0 0 3 4 5 6 \n5 0 0 4 0 0 0 \n1 3 4 0 0 0 10 \n1 4 0 0 0 8 0 \n0 5 0 0 8 0 8 \n0 6 0 10 0 8 0","0 0\n1 2\n2 5\n3 1\n4 1\n5 7\n6 8"],["6\n0 1 0 0 0 1 \n1 0 1 0 1 0 \n0 1 0 1 0 1 \n0 0 1 0 1 0 \n0 1 0 1 0 0 \n1 0 1 0 0 0","0 0\n1 1\n2 2\n3 3\n4 2\n5 1"],["8\n0 1 0 3 0 1 0 0 \n1 0 1 0 1 0 0 0 \n0 1 0 1 0 1 3 0 \n3 0 1 0 1 0 0 3 \n0 1 0 1 0 0 0 3 \n1 0 1 0 0 0 0 0 \n0 0 3 0 0 0 0 3 \n0 0 0 3 3 0 3 0","0 0\n1 1\n2 2\n3 3\n4 2\n5 1\n6 5\n7 5"],["8\n0 1 0 3 0 1 0 0\n1 0 1 12 1 0 0 0\n0 1 0 1 0 1 3 0\n3 12 1 0 1 0 0 3\n0 1 0 1 0 0 0 3\n1 0 1 0 0 0 15 0\n0 0 3 0 0 15 0 3\n0 0 0 3 3 0 3 0","0 0\n1 1\n2 2\n3 3\n4 2\n5 1\n6 5\n7 5"],["8\n0 0 5 0 0 4 5 0\n0 0 0 6 0 6 0 2\n5 0 0 4 5 0 0 0\n0 6 4 0 4 0 6 3\n0 0 5 4 0 0 0 0\n4 6 0 0 0 0 6 0\n5 0 0 6 0 6 0 0\n0 2 0 3 0 0 0 0","0 0\n1 10\n2 5\n3 9\n4 10\n5 4\n6 5\n7 12"]],"are_all_tests_scored":false,"are_all_tests_run":true},"subtitles":{},"tests_archive":"/api/step-sources/1454297/tests","feedback_correct":"","feedback_wrong":""},"id":"1454297","has_review":false,"time":"2020-09-06T14:52:16.891Z"}